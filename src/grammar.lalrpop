use std::convert::TryInto;
use crate::ast::{Expr, Stmt, self};
use crate::util::{concat, parse_str_prefix};

grammar;

extern {
  type Error = String;
}

match {
  // Skip extra whitespace
  r"\s*" => { },
  // Skip `//` comments
  r"//[^\n\r]*[\n\r]*" => { },
  _,
}

// Top-level program
// Can have an optional return value (or use the main() function instead)
pub Program: Expr = <stmts:Stmt*> <ret:Return?> =>
  ast::Block { stmts, return_value: ret.map(Into::into) }.into();

// A block with a return value
// Used for function bodies and block expressions.
Block: Expr = <stmts:Stmt*> <ret:Return> =>
  ast::Block { stmts, return_value: Some(ret.into()) }.into();

// A collection of statements with no return value
// Used for library files and for the body of if statements
pub Stmts: ast::Stmts = <stmts:Stmt*> => ast::Stmts { stmts };

Stmt: Stmt = {
  FnDef,
  Assign,
  IfStmt,
}

Expr: Expr = {
  SimpleExpr,
  And,
  Or,
  IfExpr,
  ChildDerive,
  FnExpr,
  Infix,
  Not,
};

SimpleExpr: Expr = {
  Number,
  Ident,
  Call,
  Thresh,
  BlockExpr,
  Array,
  ArrayAccess,
  Duration,
  DateTime,
  BtcAmount,
  PubKey,
  Bytes,
  String,
  ScriptFrag,
  InfixProb,
  Paren<And>,
  Paren<Or>,
  Paren<ChildDerive>,
  Paren<FnExpr>,
  Paren<Infix>,
  Paren<Not>,
  Paren<IfExpr>,
  Paren<SimpleExpr>,
};

SExpr: Expr = {
  Number,
  Ident,
  Bytes,
  String,
  Call,
  BlockExpr,
};

Return: Expr = {
  Expr, // the preferred form
  "return" <Expr> ";"?,
};

// Expressions

Number: Expr = <INumber> => ast::Expr::Number(<>).into();
INumber: i64 = <s:r"-?\d{1,39}"> => <>.parse().unwrap();

IdentTerm: ast::Ident = <s:r"[a-zA-Z_$][a-zA-Z0-9_$]{0,38}"> => ast::Ident(<>.into());
Ident: Expr = IdentTerm => <>.into();

Call: Expr = <ident:IdentTerm> "(" <args:List0<Expr, ",">> ")" =>
    ast::Call { ident, args }.into();

IfExpr: Expr = "if" <condition:Expr> "then" <then_val:Expr> "else" <else_val:Expr> =>
    ast::IfExpr { condition: condition.into(), then_val: then_val.into(), else_val: else_val.into() }.into();

And: Expr = <List2<AndOrBranch, "&&">> => ast::And(<>).into();
Or: Expr = <List2<AndOrBranch, "||">> => ast::Or(<>).into();
AndOrBranch = { SimpleExpr, ChildDerive };

Thresh: Expr = <thresh:SExpr> "of" <policies:SimpleExpr> =>
  ast::Thresh { thresh: thresh.into(), policies: policies.into() }.into();

BlockExpr: Expr = "{" <Block> "}" => <>.into();

// Standard square brackets array - [E1, E2, E3, ...]
ArraySquare: Expr = "[" <List0<Expr, ",">> "]" =>
  ast::Array(<>).into();

// Support curly brackets arrays with exactly two elements: {E1,E2}
// For compatibility with the BIP386 tr() Output Descriptor syntax for script trees
ArrayCurly: Expr = "{" <e1:Expr> "," <e2:Expr> "}" =>
  ast::Array(vec![e1, e2]).into();

Array: Expr = { ArraySquare, ArrayCurly }

ArrayAccess: Expr = <array:ArrayAccessLHS> "." <index:ArrayAccessRHS> =>
  ast::ArrayAccess { array: array.into(), index: index.into() }.into();
ArrayAccessLHS = { Ident, Call, Array, BlockExpr, Bytes, ArrayAccess };
ArrayAccessRHS = { SExpr, Paren<Expr> };

// An xpub or compressed standalone public key (uncompressed is unsupported), with optional bip32 origin
PubKey: Expr = <s:r"(\[[a-fA-F0-9]{8}(/\d+['h]?)*\])?([a-fA-F0-9]{66}|([xt]pub[0-9a-zA-Z]{100,120}))"> =>
    Expr::PubKey(<>.into());

Bytes: Expr = {
  <s:r"0x[a-fA-F0-9]*"> =>? Expr::bytes_from_hex(&<>[2..]),

  // Bytes are typically constructed with the `0x` prefix, but can be constructed without
  // it if the length is exactly 32 or 20 bytes. This is done for compatibility with the
  // Miniscript Policy syntax for hash and x-only-pubkey literals. The Bytes value will
  // later get coerced into a PubKey/Hash as needed.
  <s:r"[a-fA-F0-9]{64}|[a-fA-F0-9]{40}"> =>? Expr::bytes_from_hex(&<>),
};

String: Expr = {
  <s:r#""([^\\"]|\\[\\ntr"])*""#> => Expr::string_from_escaped_str(&<>[1..<>.len()-1]),
};

// BIP32 child key derivation
ChildDerive: Expr = {
    <parent:SimpleExpr> "/" <path:List1<ChildDerivePart, "/">> <wildcard:ChildDeriveWildcard?> =>
      ast::ChildDerive { parent: parent.into(), path, is_wildcard: wildcard.is_some() }.into(),
    <parent:SimpleExpr> <wildcard:ChildDeriveWildcard> =>
      ast::ChildDerive { parent: parent.into(), path: vec![], is_wildcard: true }.into(),
};
ChildDerivePart: Expr = {
  SimpleExpr,
  // For compatibility with the BIP389 multipath descriptor syntax: XPUB/0/<0;1>/9
  // This can alternatively be expressed using standard Minsc arrays: XPUB/0/[0,1]/9
  "<" <List2<SimpleExpr, ";">> ">" => ast::Array(<>).into(),
};
// Allow `xpub/ *` so that it doesn't look like a comment.
ChildDeriveWildcard = { "/*", "/ *" };

ScriptFrag: Expr = "`" <fragments:ScriptFragPart*> "`" =>
  ast::ScriptFrag { fragments }.into();
ScriptFragPart = { ScriptFragPart_, "<" <SimpleExpr> ">" };
ScriptFragPart_ = { Ident, Number, Call, BlockExpr, ArrayAccess, PubKey, Bytes, String };

FnExpr: Expr = <signature:FnExprSignature> <body:Expr> =>
    ast::FnExpr { signature, body: body.into() }.into();
FnExprSignature = {
  "|" <List0<IdentTerm, ",">> "|",
  // No arguments should already be captured by the `List0`, but for some reason it isn't.
  // Possibly because `||` is also a terminal for policy OR?
  "||" => vec![],
};

// Infix op with two operands
Infix: Expr = <lhs:SimpleExpr> <op:InfixOp> <rhs:Expr> =>
   ast::Infix { op, lhs: lhs.into(), rhs: rhs.into() }.into();

InfixOp: ast::InfixOp = {
  "+" => ast::InfixOp::Add,
  "-" => ast::InfixOp::Subtract,
  "==" => ast::InfixOp::Eq,
  "!=" => ast::InfixOp::NotEq,
  ">" => ast::InfixOp::Gt,
  "<" => ast::InfixOp::Lt,
  ">=" => ast::InfixOp::Gte,
  "<=" => ast::InfixOp::Lte,
};

// This is defined separately from InfixOp with less options for the LHS/RHS, so that
// it can be used unambiguously as an AndOrBranch element without requiring parenthesis.
InfixProb: Expr = <lhs:SExpr> "@" <rhs:SimpleExpr> =>
  ast::Infix { op: ast::InfixOp::Prob, lhs: lhs.into(), rhs: rhs.into() }.into();

Not: Expr = "!" <Expr> =>
  ast::Not(<>.into()).into();

// Duration and times

Duration = { DurationBlocks, DurationClock };

DurationBlocks: Expr = r"\d+\s+blocks?" =>
  ast::Duration::BlockHeight(parse_str_prefix(<>)).into();

DurationClock: Expr = <heightwise:"heightwise"?> <parts:DurationClockPart+>  =>
  ast::Duration::BlockTime { parts, heightwise: heightwise.is_some() }.into();

DurationClockPart: ast::DurationPart = {
  <n:INumber> YearsAliases => ast::DurationPart::Years(n.try_into().unwrap()),
  <n:INumber> MonthsAliases => ast::DurationPart::Months(n.try_into().unwrap()),
  <n:INumber> WeeksAliases => ast::DurationPart::Weeks(n.try_into().unwrap()),
  <n:INumber> DaysAliases => ast::DurationPart::Days(n.try_into().unwrap()),
  <n:INumber> HoursAliases => ast::DurationPart::Hours(n.try_into().unwrap()),
  <n:INumber> MinutesAliases => ast::DurationPart::Minutes(n.try_into().unwrap()),
  <n:INumber> SecondsAliases => ast::DurationPart::Seconds(n.try_into().unwrap()),
}
YearsAliases: &'input str = { "year", "years" };
MonthsAliases: &'input str = { "month", "months" };
WeeksAliases: &'input str = { "week", "weeks" };
DaysAliases: &'input str = { "day", "days" };
HoursAliases: &'input str = { "hour", "hours" };
MinutesAliases: &'input str = { "mins", "minute", "minutes" };
SecondsAliases: &'input str = { "second", "seconds" };

DateTime: Expr = r"\d{4}-\d{1,2}-\d{1,2}(\s+\d{1,2}:\d{1,2})?" =>
  ast::DateTime(<>.into()).into();

BtcAmount: Expr = r"(-?\d+(?:\.\d+)?) (BTC|mBTC|uBTC|bits?|satoshis?|sats?|msats?)" =>?
  Ok(Expr::BtcAmount(<>.parse().map_err(|e| format!("invalid BTC amount \"{}\": {}", <>, e))?));

// Statements

Assign: Stmt = "let"? <assigns:List1<Assignment, ",">> ";" =>
    ast::Assign(assigns).into();

Assignment: ast::Assignment = <lhs:IdentTerm> "=" <rhs:Expr> =>
    ast::Assignment { lhs, rhs };

FnDef: Stmt = {
    "fn" <ident:IdentTerm> "(" <signature:List0<IdentTerm, ",">> ")" "=" <body:Expr> ";" =>
        ast::FnDef { ident, signature, body }.into(),
    "fn" <ident:IdentTerm> "(" <signature:List0<IdentTerm, ",">> ")" "{" <body:Block> "}" ";"? =>
        ast::FnDef { ident, signature, body }.into(),
}

IfStmt: Stmt = "if" <condition:Expr> "{" <then_body:Stmts> "}" <else_body:IfStmtElse?> =>
    ast::IfStmt { condition: condition.into(), then_body: then_body.into(), else_body: else_body.into() }.into();
IfStmtElse: ast::Stmts = "else" "{" <Stmts> "}";


// Helpers

// A `S`-separated list of zero or more `T` values
List0<T, S>: Vec<T> = <l:(<T> S)*> <t:T?> => concat(l, t);

// A `S`-separated list of one or more `T` values
List1<T, S>: Vec<T> = <l:(<T> S)*> <t:T> => concat(l, Some(t));

// A `S`-separated list of two or more `T` values
List2<T, S>: Vec<T> = <l:(<T> S)+> <t:T> => concat(l, Some(t));

Paren<T> = "(" <T> ")";
