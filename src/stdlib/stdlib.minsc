// Opcodes
// Generated with: curl -s https://raw.githubusercontent.com/rust-bitcoin/rust-bitcoin/master/src/blockdata/opcodes.rs | grep 'pub const'  | sed -r 's/.*(OP_\w+).* (0x\w{2}).*/\1 = script(\2),/' | egrep -v 'OP_RETURN_|PUSHNUM|PUSHBYTES|NOP|INVALIDOPCODE')
OP_PUSHDATA1 = script(0x4c), OP_PUSHDATA2 = script(0x4d), OP_PUSHDATA4 = script(0x4e), OP_RESERVED = script(0x50), OP_VER = script(0x62), OP_IF = script(0x63), OP_NOTIF = script(0x64), OP_VERIF = script(0x65), OP_VERNOTIF = script(0x66), OP_ELSE = script(0x67), OP_ENDIF = script(0x68), OP_VERIFY = script(0x69), OP_RETURN = script(0x6a), OP_TOALTSTACK = script(0x6b), OP_FROMALTSTACK = script(0x6c), OP_2DROP = script(0x6d), OP_2DUP = script(0x6e), OP_3DUP = script(0x6f), OP_2OVER = script(0x70), OP_2ROT = script(0x71), OP_2SWAP = script(0x72), OP_IFDUP = script(0x73), OP_DEPTH = script(0x74), OP_DROP = script(0x75), OP_DUP = script(0x76), OP_NIP = script(0x77), OP_OVER = script(0x78), OP_PICK = script(0x79), OP_ROLL = script(0x7a), OP_ROT = script(0x7b), OP_SWAP = script(0x7c), OP_TUCK = script(0x7d), OP_CAT = script(0x7e), OP_SUBSTR = script(0x7f), OP_LEFT = script(0x80), OP_RIGHT = script(0x81), OP_SIZE = script(0x82), OP_INVERT = script(0x83), OP_AND = script(0x84), OP_OR = script(0x85), OP_XOR = script(0x86), OP_EQUAL = script(0x87), OP_EQUALVERIFY = script(0x88), OP_RESERVED1 = script(0x89), OP_RESERVED2 = script(0x8a), OP_1ADD = script(0x8b), OP_1SUB = script(0x8c), OP_2MUL = script(0x8d), OP_2DIV = script(0x8e), OP_NEGATE = script(0x8f), OP_ABS = script(0x90), OP_NOT = script(0x91), OP_0NOTEQUAL = script(0x92), OP_ADD = script(0x93), OP_SUB = script(0x94), OP_MUL = script(0x95), OP_DIV = script(0x96), OP_MOD = script(0x97), OP_LSHIFT = script(0x98), OP_RSHIFT = script(0x99), OP_BOOLAND = script(0x9a), OP_BOOLOR = script(0x9b), OP_NUMEQUAL = script(0x9c), OP_NUMEQUALVERIFY = script(0x9d), OP_NUMNOTEQUAL = script(0x9e), OP_LESSTHAN = script(0x9f), OP_GREATERTHAN = script(0xa0), OP_LESSTHANOREQUAL = script(0xa1), OP_GREATERTHANOREQUAL = script(0xa2), OP_MIN = script(0xa3), OP_MAX = script(0xa4), OP_WITHIN = script(0xa5), OP_RIPEMD160 = script(0xa6), OP_SHA1 = script(0xa7), OP_SHA256 = script(0xa8), OP_HASH160 = script(0xa9), OP_HASH256 = script(0xaa), OP_CODESEPARATOR = script(0xab), OP_CHECKSIG = script(0xac), OP_CHECKSIGVERIFY = script(0xad), OP_CHECKMULTISIG = script(0xae), OP_CHECKMULTISIGVERIFY = script(0xaf), OP_CLTV = script(0xb1), OP_CSV = script(0xb2), OP_CHECKSIGADD = script(0xba);
OP_CHECKSEQUENCEVERIFY = OP_CSV;
OP_FALSE = `0`, OP_TRUE = `1`;

// Built-in unique Symbols
// These don't have any special meaning on the Rust side, but are used in Minsc code for various purposes
null = Symbol("null");
_ = Symbol("_");

// Some useful constants
DUST_AMOUNT = 294;
DUST_NON_SW = 546;

// A point with unknown discrete logarithm (to eliminate key-path spend)
NUMS = pubkey(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0);
TR_UNSPENDABLE = NUMS, H_POINT = NUMS;

// Some aliases until I figure out what I like best
Script=script, Transaction=transaction, Address=address, PubKey=pubkey, Bytes=bytes, String=str, Int=int, Float=float, tx=Transaction;

//
// Array utilities
//

fn first($arr) = $arr.0;
fn last($arr) = $arr.(len($arr) - 1);
fn range($start, $end) = repeat(($end-$start)+1, |$n| $start+$n);
fn keys($arr) = range(0, len($arr) - 1);
fn slice($arr, $start, $len) = map(range($start, $start + $len - 1), |$n| $arr.$n);
fn tail($arr) = slice($arr, 1, len($arr) - 1); // get all but first element
fn initial($arr) = slice($arr, 0, len($arr) - 1); // get all but last element

fn flatMap($arr, $$fn) = reduce($arr, [], |$acc, $el| $acc + $$fn($el));
fn map($arr, $$fn) = flatMap($arr, |$el| [ $$fn($el) ]);
fn filter($arr, $$fn) = flatMap($arr, |$el| if $$fn($el) then [ $el ] else [ ]);

//
// Altstack utilities
//

// ROLL/PICK from the altstack. $n must be known statically (cannot be read from the stack)
fn rollAlt($n) = `
  repeat($n, OP_FROMALTSTACK)
  repeat($n - 1, `OP_SWAP OP_TOALTSTACK`)
`;
fn pickAlt($n) = `
  repeat($n, OP_FROMALTSTACK)
  OP_DUP OP_TOALTSTACK
  repeat($n - 1, `OP_SWAP OP_TOALTSTACK`)
`;
rollFromAltStack=rollAlt, pickFromAltStack=pickAlt;

// Read the top stack item as the number of stack items to send to the altstack
// stack in: <el1> <el2> .. <elN> <N total>, stack out: (empty)
// altstack out: <elN> .. <el2> <el1> <N total>
fn nToAlt($max_iterations) = `
  OP_DUP // keep a copy of the total number of elements
  // stack: <el1> <el2> .. <elN> <N total> <N counter>
  unrollFor($max_iterations, `OP_ROT OP_TOALTSTACK`)
  OP_TOALTSTACK // send the total number of elements as the final altstack item
`;

// The reverse of nToAlt() - bring back items from the altstack to the stack
// stack in: (none), stack out: <el1> <el2> .. <elN> <N total>
// altstack in: <elN> .. <el2> <el1> <N total>, altstack out: (empty)
fn nFromAlt($max_iterations) = `
  OP_FROMALTSTACK
  OP_DUP // keep a copy of the total number of elements
  // stack: <N total> <N counter>, alt stack: <el1> <el2> .. <elN>
  unrollFor($max_iterations, `OP_FROMALTSTACK OP_ROT OP_ROT`)
`;


//
// Control structure utilities
//

// Match the item at the top of the stack against the clauses and run the matching script, or abort if there's no match
// Each clause is a tuple of [ $condition_code, $body_code ]. For example: switch([ [ `0 OP_EQUAL`, handleFoo ], [ `1 OP_EQUAL`, handleBar ] ])
// Clause conditions are expected to consume the value being matched (e.g. with OP_EQUAL). It will be DUPd for them.
// The last clause can be provided as a single element `[ $body_code ]` with no condition to be used as the default branch.
fn switch($clauses) = `
  map(initial($clauses), |$clause|
    `OP_DUP $clause.0 OP_IF OP_DROP $clause.1 OP_ELSE`)
  // Using OP_VERIFY instead of another IF..ELSE for the last fragment saves 4 bytes
  last($clauses).0 {if len(last($clauses)) == 2 then `OP_VERIFY last($clauses).1` else ``}
  repeat(len($clauses) - 1, OP_ENDIF)
`;

// Pop an index number off the stack and execute the script branch with that index
// For example select([ handleFoo, handleBar ]) to run `handleFoo` if the top stack
// element is 0, `handleBar` if its 1, or fail the script if its neither
fn select($scripts) =
  if len($scripts) == 2 // special case optimization for 2 branches
    then `OP_IF $scripts.0 OP_ELSE $scripts.1 OP_ENDIF`
    else switch(map(keys($scripts), |$n| [ `$n OP_EQUAL`, $scripts.$n ]))
;


//
// Looping utilities
//

// Loop unrolling: run $loop_body as long as $condition is met, up to $max_iterations times
// $loop_body can be a Script or a Function that accepts the iteration count and returns a Script.
// For example: `<num> unrollLoop(50, `OP_DUP 0 OP_GREATERTHANOREQUAL`, `OP_1SUB`)` to count down from <num> to 0, for <num>s of up to 50
// more advanced example with some comments: https://gist.github.com/shesek/758c25489869d77d4ef624ea43f18c49
fn unrollLoop($max_iterations, $condition, $loop_body) {
  $loop_fn = if typeof($loop_body) == "function" then $loop_body else |_| $loop_body;

  fn _unrollLoop($loop_i) =
    if $max_iterations > $loop_i
      then `$condition OP_IF $loop_fn($loop_i) _unrollLoop($loop_i+1) OP_ENDIF`
      else `$condition OP_NOT OP_VERIFY` // fail the script if the condition is still met after $max_iterations
  ;
  _unrollLoop(0)
}

// Read the top stack item as the number of times to run $for_body
// Example with accumulator: `0 <num> unrollFor(50, `OP_DUP OP_ROT OP_ADD OP_SWAP`)` to sum the numbers from <num> to 1
fn unrollFor($max_iterations, $for_body) {
  $for_fn = if typeof($for_body) == "function" then $for_body else |_| $for_body;
  `
    unrollLoop($max_iterations, `OP_DUP OP_0NOTEQUAL`, |$for_i| `$for_fn($for_i) OP_1SUB`)
    OP_DROP // drop the counter (always 0 by now)
  `
}

// Function form for assigning execution probabilities
fn prob($n, $val) = $n@$val;

// For compatibility with code that uses the old `iif()` function, which was replaced
// with if..then..else expressions. Will probably be eventually removed.
fn iif($condition, $then, $else) {
  $result = if $condition then $then else $else;
  if typeof($result) == "function" then $result()
  else $result
}
